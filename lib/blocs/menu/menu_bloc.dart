import 'dart:async';
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../services/menu_service.dart';
import '../../models/menu_item_model.dart';
import 'menu_event.dart';
import 'menu_state.dart';

class MenuBloc extends Bloc<MenuEvent, MenuState> {
  final MenuService _menuService;
  StreamSubscription? _menuSubscription;

  MenuBloc({required MenuService menuService})
    : _menuService = menuService,
      super(MenuInitial()) {
    on<LoadMenu>(_onLoadMenu);
    on<AddMenuItem>(_onAddMenuItem);
    on<UpdateMenuItem>(_onUpdateMenuItem);
    on<DeleteMenuItem>(_onDeleteMenuItem);
    on<ToggleAvailability>(_onToggleAvailability);
    on<_MenuUpdated>(_onMenuUpdated);
    on<_MenuErrorEvent>(_onMenuError);
  }

  @override
  Future<void> close() {
    _menuSubscription?.cancel();
    return super.close();
  }

  void _onLoadMenu(LoadMenu event, Emitter<MenuState> emit) {
    emit(MenuLoading());
    _menuSubscription?.cancel();
    _menuSubscription = _menuService.getMenuItems().listen(
      (items) async {
        try {
          // Hybrid: Merge Firestore items with REST availability
          final availabilityMap = await _menuService.getAvailabilityMap();
          final mergedItems = items.map((item) {
            final isAvailable = availabilityMap[item.id] ?? item.isAvailable;
            return item.copyWith(isAvailable: isAvailable);
          }).toList();

          add(_MenuUpdated(mergedItems));
        } catch (e) {
          add(_MenuUpdated(items)); // Fallback
        }
      },
      onError: (error) {
        add(_MenuErrorEvent(error.toString()));
      },
    );
  }

  // Internal events to handle stream updates
  void _onMenuUpdated(_MenuUpdated event, Emitter<MenuState> emit) {
    emit(MenuLoaded(event.items));
  }

  void _onMenuError(_MenuErrorEvent event, Emitter<MenuState> emit) {
    emit(MenuError(event.message));
  }

  Future<void> _onAddMenuItem(
    AddMenuItem event,
    Emitter<MenuState> emit,
  ) async {
    try {
      // Don't emit loading here if we want to keep showing the list, state management depends on UI needs.
      // But typically we show a loading indicator or snackbar.
      // For simplicity let's rely on the stream update to refresh the UI.

      final tempId = DateTime.now().millisecondsSinceEpoch.toString();
      String? imageUrl;
      if (event.imageFile != null) {
        imageUrl = await _menuService.uploadMenuImage(event.imageFile!, tempId);
      }

      final menuItem = MenuItem(
        id: '', // Generated by Firestore
        name: event.name,
        description: event.description,
        price: event.price,
        imageUrl: imageUrl,
        isAvailable: true,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      await _menuService.addMenuItem(menuItem);
      // Stream will update state
    } catch (e) {
      emit(MenuError(e.toString()));
      // Re-emit loaded state if possible?
      // BLoC pattern usually requires specific error handling
    }
  }

  Future<void> _onUpdateMenuItem(
    UpdateMenuItem event,
    Emitter<MenuState> emit,
  ) async {
    try {
      String? imageUrl = event.existingImageUrl;
      if (event.newImageFile != null) {
        imageUrl = await _menuService.uploadMenuImage(
          event.newImageFile!,
          event.id,
        );
      }

      final menuItem = MenuItem(
        id: event.id,
        name: event.name,
        description: event.description,
        price: event.price,
        imageUrl: imageUrl,
        isAvailable: event.isAvailable,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      await _menuService.updateMenuItem(event.id, menuItem);
    } catch (e) {
      emit(MenuError(e.toString()));
    }
  }

  Future<void> _onDeleteMenuItem(
    DeleteMenuItem event,
    Emitter<MenuState> emit,
  ) async {
    try {
      await _menuService.deleteMenuItem(event.id);
    } catch (e) {
      emit(MenuError(e.toString()));
    }
  }

  Future<void> _onToggleAvailability(
    ToggleAvailability event,
    Emitter<MenuState> emit,
  ) async {
    final currentState = state;
    if (currentState is MenuLoaded) {
      // Optimistic Update
      final index = currentState.items.indexWhere(
        (item) => item.id == event.id,
      );
      if (index != -1) {
        final updatedItems = List<MenuItem>.from(currentState.items);
        updatedItems[index] = updatedItems[index].copyWith(
          isAvailable: event.isAvailable,
        );
        emit(MenuLoaded(updatedItems));

        try {
          await _menuService.toggleAvailability(event.id, event.isAvailable);
          // Stream might trigger refresh too, but optimistic update makes UI instant
        } catch (e) {
          // Revert
          emit(MenuLoaded(currentState.items));
          emit(MenuError(e.toString()));
          // Restore loaded state
          emit(MenuLoaded(currentState.items));
        }
      }
    }
  }
}

// Private events
class _MenuUpdated extends MenuEvent {
  final List<MenuItem> items;
  const _MenuUpdated(this.items);
  @override
  List<Object> get props => [items];
}

class _MenuErrorEvent extends MenuEvent {
  final String message;
  const _MenuErrorEvent(this.message);
  @override
  List<Object> get props => [message];
}
